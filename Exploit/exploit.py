#Yam chernichovsky 
from header import *

from_as_header_struct = struct.Struct('> B H I')                                #header of message send from authentication server                          version,code,payload size
encrypted_key_ipport_struct = struct.Struct('> 16s 48s 9s 5s')                               #struct send from authentication server as part of symetric key (1603)      IV,AES_KEY
message_to_m_server_struct = struct.Struct('> I 16s')

#msg1 from authentication server to client as sent by the authentication server
#msg2 from client message to mesage server as recived by the message server
msg1= b'\x18\x06C\x00\x00\x00\xe0\x9b\xf2\x7f\x96\x9as\xc5%\xee\xef|\xa5#ac\x07\x1e\xd2\x17E\xf1ub\x0c\x84\x88qId3\x7f\xe2A\x9c\xac\xe9P\x9bN\xc6O\xe7\xb5\x88\xc7\xe5x\xdb\xf20\\\xc1\xe4\xd1\x0c0\xa6\x81\xda\x9eZ\xf4\xdb=127.0.0.158916\x18\xccb\x10\xe4\x13rD\xe6\xd7SU\xcc\x85}Q@K\xa7o\xd0\x03\n\xeb\x82\xe9\xf3\xc6S\xf1q+\xc11710317371.644085\x9b\xf2\x7f\x96\x9as\xc5%\xee\xef|\xa5#ac\x07i\x94"[|\xe4"*\x18\xda\xfe\x8d\xa0"\xe5\x12T\x89\x97\x0f\x89w\xf41\xd1:\x969O\x016\x9c\x11\xfc)\x8ct\xb2$\xd3X\x8a\xfc\xefz\xd9\x93\xbcy\xc2\x1a\x1c^\xabL\xd8|\x85\x0c\tC xiP`\x02\x18\x86^\xa4\x1d\xa4\xf5B\x8e\xe5|>\x12'
msg2= b'\xccb\x10\xe4\x13rD\xe6\xd7SU\xcc\x85}Q@\x18\x04\x04\x00\x00\x01\x02}\xfcU\x8b#S\x07\xaf\x00#\x83/\x17+]@_3c0\xff\xecc}\x97\xc5A\xb7QB<K.r\x16L\xcb[\xe8q\xf2\x9b\xc6\xd1\x07\x1b=4\xb9<\xa4\xe6Tu\xfay_D\xe8.\xb0\x8c\x95.\xaeB\xdb\xf6\xac|%\x8dEU\x05\xd5\xdbdQ\x1as\x14<m\xfa\xc1\x83PC[\xac\x94y\x07\x98C\x9d\x8fXc~\xa9w\xe4\x10s\'\xf9`\xd1\xa3\xc5\x18\xccb\x10\xe4\x13rD\xe6\xd7SU\xcc\x85}Q@K\xa7o\xd0\x03\n\xeb\x82\xe9\xf3\xc6S\xf1q+\xc11710317371.644085\x9b\xf2\x7f\x96\x9as\xc5%\xee\xef|\xa5#ac\x07i\x94"[|\xe4"*\x18\xda\xfe\x8d\xa0"\xe5\x12T\x89\x97\x0f\x89w\xf41\xd1:\x969O\x016\x9c\x11\xfc)\x8ct\xb2$\xd3X\x8a\xfc\xefz\xd9\x93\xbcy\xc2\x1a\x1c^\xabL\xd8|\x85\x0c\tC xiP`\x02\x18\x86^\xa4\x1d\xa4\xf5B\x8e\xe5|>\x12'


def decrypt_AES(data, key , iv):
    key = key[:32]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_data = cipher.decrypt(data)
    return decrypted_data

def unpad_AES(data):
    unpadded_data = unpad(data, AES.block_size)
    return unpadded_data

def hash_SHA256_ret_bytes(data):  # take string and Returns the hash as bytes
    data = data.encode()
    hash_object = hashlib.sha256(data)
    hash_bytes = hash_object.digest()
    return hash_bytes

def send_data_to_server(ip,port,buffer): #return server answer
    ip = ip.decode()
    port = int(port.decode())
    server_address = (ip, port)
    
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
            # Connect to the server
            print(f"Connecting to {server_address}")
            client_socket.connect(server_address)
            client_socket.sendall(buffer)
            data = client_socket.recv(1024)
            return data
    except ConnectionRefusedError:
            print("The server refused the connection")
            return 0
    except ConnectionResetError:
            print("The server reset the connection")
            return 0
    except socket.error as e:
        print(f"Failed to send data to the server: {e}")
    finally:
            # Close the socket
            client_socket.close()
            print("Socket closed.")



#m_server_ans = talk_to_connected_m_server(ticket_client_id,ticket_server_id,msg,decrypted_key,iv,server_ip,server_port)
def talk_to_connected_m_server(client_id_bin,server_id,message,aes_key,iv,ip,port):
    message = message.encode()
    aes_key = unpad_AES(aes_key)
    print('unpadded_aes_key: ',aes_key)
    server_id = hex_ascii_to_bin(server_id)
    encrypted_message = encrypt_AES(message, aes_key, iv)
    message_size = len(encrypted_message)
    buffer = bytearray(to_server_header_struct.size+message_to_m_server_struct.size+message_size)
    to_server_header_struct.pack_into(buffer,0,client_id_bin,VERSION,CODE_TO_M_SERVER_MAS_SEND,message_to_m_server_struct.size+message_size)
    message_to_m_server_struct.pack_into(buffer,to_server_header_struct.size,message_size,iv)
    buffer[to_server_header_struct.size+message_to_m_server_struct.size:to_server_header_struct.size+message_to_m_server_struct.size+message_size] = encrypted_message
    m_server_ans = send_data_to_server(ip,port,buffer)
    return m_server_ans    

def init():
    #get the first aes(key for m server and client, password hash, iv) encrypted by the client password hash 
    enckrypted_key = encrypted_key_ipport_struct.unpack(msg1[from_as_header_struct.size:from_as_header_struct.size+encrypted_key_ipport_struct.size])
    iv = enckrypted_key[0]                                                                 ## this is what i need                                            ## this is what i need
    aes_key_encrypted_by_client_key = enckrypted_key[1]                                      ## this is what i need                                 ####this is what i need 
    server_ip = enckrypted_key[2]         
    server_port = enckrypted_key[3]

    authenticatoer = authenticator_struc.unpack(msg2[to_server_header_struct.size:to_server_header_struct.size+authenticator_struc.size])
    authenticator_version_encrypted = authenticatoer[0]       #encrypted by Kcm
    authenticator_client_id_encrypted = authenticatoer[1]     #encrypted by Kcm
    authenticator_server_id_encrypted = authenticatoer[2]     #encrypted by Kcm
    authenticator_timestamp_encrypted = authenticatoer[3]     #encrypted by Kcm

    ticket = ticket_struct.unpack(msg2[to_server_header_struct.size+authenticator_struc.size:to_server_header_struct.size+authenticator_struc.size+ticket_struct.size])
    ticket_version = ticket[0]
    ticket_client_id = ticket[1]
    ticket_server_id = bin_to_hex_ascii(ticket[2])
    ticket_timestamp = ticket[3]    #not in use
    ticket_iv = ticket[4]
    ticket_aes_key = ticket[5]
    ticket_expiration_time = ticket[6]

        
    with open('password_notebook.txt', 'r') as password_file:
        # For each line in the password notebook file
        for line in password_file:
            # Remove the newline character at the end of the line
            password = line.rstrip('\n')
            print(f"password : {password}")
                    #get decryped Kcm by password hash
            decrypted_key = decrypt_AES(aes_key_encrypted_by_client_key,hash_SHA256_ret_bytes(password),iv)
            #test the key
            #rint('decrypted_key: ',decrypted_key)
            #print('authenticator_version_encrypted: ',authenticator_version_encrypted)
            dec_version_padded = decrypt_AES(authenticator_version_encrypted,decrypted_key,iv)
            #print('decrypt_AES(authenticator_version_encrypted,decrypted_key,iv): ',dec_version_padded)
            unpad_dec_version =  dec_version_padded.rstrip(b'\x0f')
            int_version = int.from_bytes(unpad_dec_version, byteorder='big')
            #print('version: ',int_version)
            if (int_version == VERSION): 
                print("\n\n the version is good \n\n")
                #print("ticket_client_id: ",ticket_client_id)
                dec_client_uuid = decrypt_AES(authenticator_client_id_encrypted,decrypted_key,iv)
                unpad_dec_client_uuid =  dec_client_uuid.rstrip(b'\x10')
                print('dec_client_uuid_unpad: ',unpad_dec_client_uuid)
                if (unpad_dec_client_uuid == ticket_client_id):
                    print('\n\n the client uuid id is good \n\n')
                    dec_server_uuid = decrypt_AES(authenticator_server_id_encrypted,decrypted_key,iv)
                    unpad_dec_server_uuid =  dec_server_uuid.rstrip(b'\x10')
                    str_unpad_dec_server_uuid = bin_to_hex_ascii(unpad_dec_server_uuid)
                    #print('dec_server_uuid: ',dec_server_uuid)
                    #print('ticket_server_id: ',ticket_server_id)
                    #print('str_unpad_dec_server_uuid: ',str_unpad_dec_server_uuid)
                    if (str_unpad_dec_server_uuid == ticket_server_id):
                        #print('the key is good')
                        #get the server ip and port
                        print("found the password, here is the info:")
                        print('server ip: ',server_ip,'server port: ',server_port, 'client id: ',unpad_dec_client_uuid,'server id: ',str_unpad_dec_server_uuid)
                        print('client password: ',password, 'client and server comunication secret key: ',decrypted_key)
                        #now we can start the comunication with the server                       
                        print('\n\n iv :', iv, 'ticket_iv :', ticket_iv, ' \n\n ')
                        print("test the comunication with the server, send a message to the server ")
                        msg = input("Enter a message to send to the server: ")
                        m_server_ans = talk_to_connected_m_server(ticket_client_id,ticket_server_id,msg,decrypted_key,iv,server_ip,server_port)
                        print('m_server_ans: ',m_server_ans)
                        break


    print ("end")



def main():
    init()
if __name__ == "__main__":
    main()


#need to think about the darta types and the padding
    

